\section{Phase I: Client Key Management}
Phase I builds out public-key driven session key negotiation for Zoom Meetings. Let's first dive into how Zoom Meetings works, and then propose changes.
\subsection{Current Design}

Each standard Zoom call is an interaction with up to 1,000 participants. Meetings are identified externally by a short meeting identifier.

Each Zoom meeting is initiated by a designated individual, who we will refer to as the host. The host has the ability to configure meetings, notify participants, select meeting passwords, and control meeting functions while a meeting is in progress. The host's configured policies (e.g., whether meeting participants may share their screens by default) are applied to the meeting. The host need not be present for the entire duration of a meeting: if ``Join Before Host'' is enabled, individuals can begin a meeting before the host joins. Similarly, a host can appoint one or more additional individuals as co-hosts and can leave the meeting under the control of a replacement host.

Each participant must possess the meeting ID as a precondition for joining a meeting. Current meeting IDs are short identifiers that must be known by the Zoom infrastructure to enable routing of data between meeting participants.

In the current system, access control to meetings is implemented via several mechanisms:

\begin{itemize*}
\item A shared meeting password, which can be selected by the host at the time the meeting is configured.
\item A ``waiting room'' feature, in which the host (and replacement host) has the ability to manually approve entry of participants throughout the course of a live meeting. Participants are identified by a name of their choosing.
\item A mechanism by which meeting participants must register prior to the meeting.
\item A setting to limit attendees of a meeting to those who are signed-in and authenticated members of certain domains.
\end{itemize*}

We retain these server-enforced access control features; they are largely orthogonal to the E2E encryption design aside from where described.

\subsection{Meeting UI Changes}

The meeting setup interface will feature a new checkbox: ``End-to-End Security.''  This bit is persisted across the scheduling system, and cannot be unset once the meeting starts. When checked, the behavior of the meeting changes in several key ways:

\begin{itemize*}
\item The ``Enable Join Before Host'' checkbox becomes grayed out and deselected.
\item All participating clients must run the official Zoom client software; those on dial-ins, web browsers, or legacy Zoom-enabled devices are locked out of the meeting.
\item The Cloud Recording feature becomes disabled.
\end{itemize*}

Once the meeting starts, there are other important UI changes:

\begin{itemize*}
\item All participants will receive a clear indication of the security level of every meeting.
\item They can see a ``meeting security code'' that they can use to verify that no one's connection to the meeting was intercepted. The host can read this code out loud, and all participants can check that their clients display the same code.


\end{itemize*}

\subsection{A Basic E2E Key Agreement Proposal}

All meeting content sent between Zoom clients is currently encrypted using a ``meeting key'' that is distributed by the Zoom infrastructure. This key is pluralized into a set of per-client/per-stream encryption keys, which are then used to encrypt A/V and chat streams sent to other clients via Zoom's infrastructure. After the initial key sharing (and excluding value-added services such as Cloud Recording and PSTN) Zoom's infrastructure servers do not require knowledge of this key.

The goal of the new design, therefore, is simply to eliminate Zoom's role in distributing this initial shared meeting key material, and to shift this responsibility to the participating Zoom clients.

In the revised approach, all keys will be generated and distributed between individual authorized meeting participants that run the Zoom client software. No secret key material or unencrypted meeting contents will be provided to Zoom infrastructure servers, except in specific cases where this sharing is explicitly authorized by a meeting host (e.g., to support abuse reporting.)

\subsection{System Components}

The system assumes the following components:
\begin{description}
\item {\bf Identity management system.} The revised system depends on the existence of a Zoom ID management system that will be responsible for distributing cryptographic public keys generated by individual clients. This server will bind keys to Zoom user accounts where possible, and will also support clients who do not have explicit Zoom identities.

\item {\bf Signaling channel.} The system will make use of a reliable signaling channel to distribute cryptographic messages between participants in a meeting. Currently, meeting participants route control messages on TLS-tunnels over TCP, through the MMRs. TLS is terminated at Zoom's servers. This channel is suitable for our needs.

\item {\bf Bulletin board.} Participants in the channel can post cryptographic messages to a meeting-specific ``bulletin board'', where all other participants can see them. This abstraction can be implemented over the signaling channel. The server controls the bulletin board, as it controls the signaling channel itself and therefore can tamper with it.

\item {\bf Meeting leader.} The protocol overview requires that, at all times, one authorized Zoom client will be present in a meeting and considered the meeting ``leader''. This client will have the responsibility of generating the shared meeting key, authorizing new meeting participants, kicking out unwanted participants, and distributing keys. For Phase I, this leader will be the meeting host, and will fall back to the co-host with the lowest user ID if the current host leaves. In future phases, we will relax this assumption (and therefore re-enable ``Join Before Host'').

\end{description}

\subsection{Cryptographic Algorithms and Standards}

In an ideal world, all public key cryptographic operations could happen via Diffie-Hellman over Curve25519~\cite{bernstein2006curve25519}, and EdDSA over Ed25519~\cite{eddsa}. Relative to others, this curve and algorithm family have shown a consistent track record for resilience to common cryptographic attacks and implementation mistakes. These algorithms are currently in review for FIPS certification but, unfortunately, are not currently approved. Therefore, in some cases (like government uses that require FIPS certification) we must fall back to FIPS-approved algorithms, like ECDSA and ECDH over curve P-384. The protocol below has support for both algorithm families, and for now ``doubles up'' all public key operations. This technique eliminates error-prone branching. Once certification succeeds, we can safely ``no-op'' the operations over P-384.

We define several standard cryptographic schemes, and then introduce new constructions built from these schemes.

\paragraph{Signature schemes.} Our algorithms make use of two signing primitives: (1) ECDSA as specified in~\cite{fips186}, implemented over the P-384 elliptic curve, and (2) EdDSA as implemented in~\cite{rfc8032} using the Ed25519 elliptic curve. We describe these schemes using the following algorithms:

\begin{description*}
\item $\eddsakeygen() \rightarrow (\vkeddsa, \skeddsa)$. Generates an EdDSA keypair.
\item $\eddsasign(\skeddsa, M) \rightarrow \signatureeddsa$. Computes an EdDSA signature.
\item $\eddsaverify(\vkeddsa, M, \signatureeddsa) \rightarrow (\true, \false)$. Verifies an EdDSA signature.
\end{description*}

\begin{description*}
\item $\ecdsakeygen() \rightarrow (\vkecdsa, \skecdsa)$. Generates an ECDSA keypair.
\item $\ecdsasign(\skecdsa, M) \rightarrow \signatureecdsa$. Computes an ECDSA signature.
\item $\ecdsaverify(\vkecdsa, M, \signatureecdsa) \rightarrow (\true, \false)$. Verifies an ECDSA signature.
\end{description*}

\paragraph{Diffie-Hellman primitives.} We additionally specify Diffie-Hellman algorithms for P-384 (FIPS) and Curve25519~\cite{bernstein2006curve25519}. In the case of P-384, we use the standard base points and key establishment techniques defined in the appropriate NIST standards~\cite{nist80056a}.

\begin{description*}
\item $\genedkeypair() \rightarrow (\pked, \sked)$. Generates a Curve25519 Diffie-Hellman keypair.
\item $\genfipskeypair() \rightarrow (\pkfips, \skfips)$. Generates a FIPS Diffie-Hellman keypair.
\item $\dhfunced(\skedS, \pkedR) \rightarrow \sharedsecreted$. Given public and secret Curve25519 keys, outputs a shared secret.
\item $\dhfuncfips(\skfipsS, \pkfipsR) \rightarrow \sharedsecretfips$. Given public and secret FIPS keys, outputs a shared secret.
\end{description*}

We use AES in GCM mode~\cite{sp80038d} for all symmetric encryption. This is defined as follows:

\begin{description*}
\item $\aesgcmenc(K, IV, M) \rightarrow C$. On input a key, IV, and message, outputs a ciphertext.
\item $\aesgcmdec(K, IV, C) \rightarrow M$. On input a key, IV, and ciphertext, outputs a message or a distinguished {\sf error}.
\end{description*}

For key derivation, we employ the HKDF algorithm \cite{rfc5869}.
%
\paragraph{Composite signature primitives.} Our protocols employ a dual signature primitive ${\sf \dualsign}$ that combines both ECDSA and EdDSA. This scheme consists of three algorithms defined as follows: \\

%%%%%%%%%%%%%%%%%%%%%
% DUAL SIGNING KEYGEN
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \dualsignkeygen}} \\
{\bf Input:} None \\
{\bf Output:} $\vkdualsign, \skdualsign$ \\

\vspace{-1.5em}
To generate a new keypair:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Run $(\vkeddsa, \skeddsa) \leftarrow \eddsakeygen()$.
\item Run $(\vkecdsa, \skecdsa) \leftarrow \ecdsakeygen()$.
\item Return $(\vkdualsign, \skdualsign) \leftarrow \left( (\vkeddsa,\vkecdsa), (\skeddsa,\skecdsa) \right)$.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% DUAL SIGNING SIGN
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \dualsignsign}}\\
{\bf Input:} a message $M$\\
{\bf Output:} a signature $\signaturedualsign$ \\

\vspace{-1.5em}
This algorithm outputs an ``attached'' signature that contains the message contents. To generate an attached signature:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Compute $\signatureeddsa \leftarrow \eddsasign(\skeddsa, M)$.
\item Compute $\signatureecdsa \leftarrow \ecdsasign(\skecdsa, M)$.
\item Return $\signaturedualsign \leftarrow \left(M, \signatureeddsa, \signatureecdsa \right)$.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% DUAL SIGNING VERIFY
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \dualsignverify}}\\
{\bf Input:} a verification key $\vkdualsign$ and an attached signature $\signaturedualsign$\\
{\bf Output:} a result $(\true, \false)$ \\

\vspace{-1.5em}
To verify a signature:

\vspace{-1.5em}
\begin{enumerate*}
\item Parse $\vkdualsign$ as $(\vkeddsa,\vkecdsa)$.
\item Parse $\signaturedualsign$ as $\left( M, \signatureeddsa, \signatureecdsa) \right)$.
\item Compute $r_1 \leftarrow \eddsaverify(\vkeddsa, M, \signatureeddsa)$.
\item Compute $r_2 \leftarrow \ecdsaverify(\vkecdsa, M, \signatureecdsa)$.
\item Return $\true$ if $r_1 = \true$ and $r_2 = \true$. Otherwise return $\false$.
\end{enumerate*}

\paragraph{Authenticated Public-Key Encryption.} Our algorithms employ an IND-CCA-secure authenticated public-key encryption scheme ${\sf \cbox}$, similar to NaCL~\cite{nacl}'s \texttt{crypto\_box} construction. A key difference is our algorithm should be FIPS-compliant, using NIST P-384 for Diffie-Hellman, AES-GCM for a symmetric cipher, and HDKF for key derivation. We additionally include a Diffie-Hellman key share over Curve25519.\\

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX KEYGEN
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxkeygen}}\\
{\bf Input:} None \\
{\bf Output:} an encryption keypair $(\pkbox, \skbox)$ \\

\vspace{-1.5em}
To generate a keypair:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Compute $(\pked, \sked) \leftarrow \genedkeypair()$.
\item Compute $(\pkfips, \skfips) \leftarrow \genfipskeypair()$.
\item Return $(\pkbox, \skbox) \leftarrow \left( (\pked, \pkfips), (\sked, \skfips) \right)$.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX ENCRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxencrypt}} \\
{\bf Input:} Sender's secret key $\skboxS$ and receiver's public key $\pkboxR$, metadata $\metadata$, and a message $M \in \{0,1\}^{*}$. \\
{\bf Output:} a ciphertext $\ciphertext$ \\

\vspace{-1.5em}
To encrypt:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Parse $\skboxS$ as $(\skedS, \skfipsS)$.
\item Parse $\pkboxR$ as $(\pkedR, \pkfipsR)$.
\item Compute $\sharedsecreted \leftarrow \dhfunced(\skedS,\pkedR)$.
\item Compute $\sharedsecretfips \leftarrow \dhfuncfips(\skfipsS, \pkfipsR)$.
\item Generate a 256-bit random string $\randomNonce$.
\item Compute $K \leftarrow \HKDF(\sharedsecreted \| \sharedsecretfips, \pkboxR \|  \allowbreak \metadata \| \randomNonce)$.
\item Compute $C' \leftarrow \aesgcmenc(K, \vec{0}, M)$.
\item Output $C \leftarrow (C', \randomNonce)$.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX DECRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxdecrypt}} \\
{\bf Input:} Receiver's secret key $\skboxR$ and sender's public key $\pkboxS$, metadata $\metadata$ and a ciphertext $\ciphertext$. \\
{\bf Output:} a message $M$, or ${\sf error}$

To decrypt:

\vspace{-1em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Parse $\pkboxS$ as $(\pkedS, \pkfipsS)$.
\item Parse $\skboxR$ as $(\skedR, \skfipsR)$. Recompute $\pkboxR$ from this value.
\item Parse $\ciphertext$ as $(C', \randomNonce)$.
\item Compute $\sharedsecreted \leftarrow \dhfunced(\skedR,\pkedS)$.
\item Compute $\sharedsecretfips \leftarrow \dhfuncfips(\skfipsR, \pkfipsS)$.
\item Compute $K \leftarrow \HKDF(\sharedsecreted \| \sharedsecretfips, \pkboxR \| \allowbreak \metadata \| \randomNonce)$.
\item Compute $M \leftarrow \aesgcmdec(K, \vec{0}, C')$. If decryption fails, output {\sf error}. Otherwise output $M$.
\end{enumerate*}
\endgroup

\subsection{Long-term Key Management}

When users $i$ signs up, or upgrades their Zoom applications to the first version that supports E2E as described in this proposal, their clients will generate a long-term signing keypair:

\[
(\ivk_i, \isk_i) \leftarrow \dualsignkeygen()
\]

The Zoom client posts the mapping $\langle (i, \deviceid) \rightarrow \ivk_i \rangle$ to the server, signed with $\dualsignsign$ under $\isk_i$. This self-signed binding becomes available to those who join user $i$ in meetings.

The client will persist this keypair indefinitely on this device and secure $\isk_i$ using whatever mechanisms the local hardware and operating system provide. Of course, $\isk_i$ never leaves the device and must be excluded from any cloud backups.

A device may lose its long-term key after an OS reinstall, a disk corruption, an app reinstall on mobile, and so on. In this case, it appears to the system as a new device and goes through the provisioning process as a new device would.

\subsection{Join/Leave Protocol flow}

We assume each meeting is identified by its unique $\meetingID$, as in the current system. Each meeting gets its own ``bulletin board'' that's accessible to everyone who has server-gated access to the meeting. The server clears it when the meeting ends. Note that meetings can be ended then later restarted, and a meeting ID can refer to a standing or repeating meeting.

From a cryptographic perspective, the server is free to tamper with all values posted on the bulletin board. We make the case below that a malicious server that sends stale messages from a previous meeting incarnation can at best deny service, which it can do regardless.


\subsubsection{Participant Key Generation}
When any participant $i$ joins the meeting, whether before or after it starts, and whether the leader or not, it performs the following operations:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Generates new public-key \textit{ephemeral} encryption keypair: $(\pk_i, \sk_i) = \cboxkeygen()$.
\item Queries the Zoom infrastructure for the server-generated $\meetingUUID$ for this instance of this meeting; this is server-generated per-meeting-instance randomness that the individual participants cannot control.
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak \| \deviceid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Computes $\sig_i \leftarrow \dualsignsign(\isk_i, \texttt{"Zoom00EPubKeys\textbackslash0"} \| \allowbreak \binding_i)$.
\item Stores $\sk_i$ for the duration of the meeting.
\item Posts $\sig_i$ to the bulletin board, so that all participants can see it.
\end{enumerate*}
\endgroup

\subsubsection{Leader Join}

When the leader joins the meeting $\meetingID$, it:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\meetingUUID$ from the Zoom infrastructure.
\item Generates a symmetric 32-byte seed $\mk$ using a secure random number generator.
\item Computes the meeting key as $\MK \leftarrow \HKDF(\mk, \allowbreak \texttt{"Zoom00SKey\textbackslash0"} \|  \allowbreak \meetingID \|  \allowbreak \meetingUUID)$.
\item Gets the full list of participants $\participantList$ from the MMR.
\item For each participant $i \in \participantList$, it runs the ``Participant Join (Leader)'' subroutine for $i$.
\end{enumerate*}
\endgroup

\subsubsection{Participant Join (Leader)}

Given a leader $\LL$ and a participant $i$ joining meeting $\meetingID$ on $\deviceid$, the leader:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_i$ from the key server.
\item Fetches $\sig_i$ from the meeting's ``bulletin board''.
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak \| \deviceid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Verifies the signature $\sig_i$ as $\dualsignverify(\ivk_i, \allowbreak \texttt{"Zoom00EPubKeys\textbackslash0"} \| \allowbreak \binding_i)$.
\item If verification fails, it aborts.
\item Computes $\metadata \leftarrow \left( \texttt{"Zoom00SDKey\textbackslash0"}  \| \meetingID \| \allowbreak \meetingUUID \| \allowbreak \LL \| i \right)$.
\item Computes $\ciphertext \leftarrow \cboxencrypt(\sk_\LL, \pk_i, \metadata, \mk)$.
   \label{participantJoinRekeyStart}
\item Posts $(i, \ciphertext)$ to the ``bulletin board''.
   \label{participantJoinRekeyEnd}
\end{enumerate*}
\endgroup

\subsection{Participant Join (Non-Leader)}

When participant $i$ joins meeting $\meetingID$, it performs the reverse of the above procedure:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_{\LL}$ from the Key server for the leader $\LL$.
\item Fetches $\sig_{\LL}$ from the meeting's ``bulletin board''.
\item Fetches $(i, \ciphertext_i)$ from the ``bulletin board''.
\item Fetches the $\meetingUUID$ from the server.
\item Verifies $\sig_{\LL}$ as $\dualsignverify(\ivk_{\LL}, \texttt{"Zoom00EPubKeys\textbackslash0"} \|\allowbreak \binding_i)$.
\item Computes $\metadata \leftarrow \left(\texttt{"Zoom00SDKey\textbackslash0"} \| \allowbreak \meetingID \| \allowbreak \meetingUUID \| \allowbreak \LL \| i \right)$.
\item Decrypts $\mk \leftarrow \cboxdecrypt(\sk_{i}, \pk_{\LL}, \metadata \allowbreak, \ciphertext)$.
   \label{participantJoinRekeyNonLeaderStart}
\item If decryption outputs {\sf error}, it aborts.
\item Computes the meeting key as $\MK \leftarrow \HKDF(\mk, \texttt{"Zoom00SKey\textbackslash0"} \| \allowbreak \meetingID \|  \allowbreak \meetingUUID)$.
   \label{participantJoinRekeyNonLeaderEnd}
\end{enumerate*}
\endgroup

Now all participants have access to the shared meeting key $\MK$, and can encrypt and decrypt meeting streams accordingly.
